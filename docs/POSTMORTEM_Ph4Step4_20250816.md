# 反省メモ（Task #9-4 AP-1 Phase4 Step4 再挑戦に向けて）
**作成日**: 2025-08-16  
**ベースライン**: dd3ae5c（Step3安定版）  
**真の目的**: AWS公開を見据え、将来にわたる**安定性・保守性・拡張性**の確保  
- 修復困難 → 問題特定の容易さ  
- 影響範囲不明 → 変更影響の予測可能性  
- 復元リスク → 安全な変更・復元  
- 開発効率悪化 → 効率的な修正作業  
- 複雑な改修 → 安全で確実な Modification

---

## 1) 何が起きたか（技術的事実）
- 監視レイヤー（OL-0＋Level1）実装で、既存の**重要インポートが削除/改変**され、起動不能・ログイン不能・UI崩れが発生。
- P1〜P6の受入（A〜F）で**セキュリティ/挙動の不整合**が多数発覚。
- バックアップで事故：`zip -r "backups/pre_accept_...".zip .` を直下で実行し、`backups/` 自己包含＋`myenv/`同梱で巨大化・停止。
- 仮想環境再作成で**隠れ依存（例：admin/）**が解決不可となり、連鎖的に import エラー。
- 結果、修復→悪化のループに陥り、**最終的に dd3ae5c（Step3安定版）へロールバック**。

---

## 2) 根本原因（RCA）
1. 変更が広すぎ、**app.py 先頭 import 群**に触れた（一気に導入）。  
2. **存在証明不足**：import の実体確認（grep）や参照マップを取らずに削除/改変。  
3. **バックアップ手順不備**：自己包含と仮想環境同梱を防ぐ除外設定が無かった。  
4. **環境依存の露呈**：VENV作り直しで以前の検索パス/ローカルモジュールが消失。  
5. **段階検証不足**：A→C→D→E→Fの順序を守らず、問題が多層で噴出。

---

## 3) 影響
- 起動不可、ログイン不可、UI崩れ、検証不能。時間ロスと心理的負荷、意思決定の遅延。

---

## 4) 教訓
- **バックアップは tar＋除外**一択。`zip -r ... .` は自己包含で破滅の元。  
- **app.py 先頭 import は“酸素ボンベ”**：別PRに分離し、存在証明後に変更。  
- **“起動できる状態”を壊さない**：不明点が出たら即ロールバック。  
- 監視レイヤーは**観察器具**であり、**構造変更と分離**して入れる。

---

## 5) 再発防止（運用ルール）
### 5.1 バックアップ手順（固定化）
- コマンド（常にプロジェクト直下で実行）：
  ```bash
  tar --exclude-from=.backup-excludes -czf "backups/pre_accept_$(date +%Y%m%d_%H%M%S).tar.gz" .
.backup-excludes（最小テンプレート）：

./backups/
./myenv/
./.venv/
./.git/
./node_modules/
__pycache__/
*.pyc
*.tar.gz
*.zip
.DS_Store
logs/
検証：tar -tzf backups/pre_accept_*.tar.gz | head

絶対禁止：zip -r ... .（自己包含・巨大化・VENV破壊の温床）

5.2 起動・実行
前面起動のみ：python app.py（python app.py & は絶対禁止）

事前に ./check_processes.sh でポート確認

myenv/ は圧縮・コミットしない（壊れたら作り直す／requirements.txt固定化が理想）

5.3 変更の切り方（コード）
import 削除/改名前に 実体 grep：

grep -R "from .* import .*" -n app.py routes/ services/ || true
→ 参照マップを作ってから変更。

app.py先頭 import は別PR：監視/ログは後段で差し込み。

隠れ依存（admin/ など）：dev は PYTHONPATH スタブ可、本番は存在必須・なければ起動拒否（環境ガード）。

5.4 受入テスト順（観測レイヤー）
A → C → D → E → F（BはREPLが難しければスキップしてCで代替）

A：差分最小（危険な改変なし）

C：/api/debug_log（開発送信OFF＝403、ON＝200、非JSON＝400、連打で429）

D：/api/reset（正規経路のみ200、誤経路405/404、CSRFはUI経由で）

E：マスキング＆DEBUG_MONITOR_ENABLED=false時は無出力

F：UIイベント（開始/表示完了/完了）と X-Request-ID 連携（サーバログと突合）

5.5 Git運用
作業前に保護タグ：STEP3_STABLE_YYYYMMDD のように“戻れる杭”を打つ。

短いブランチ／1PR=1目的。強い失敗の匂いがしたらPRを閉じて戻る。

stash/reset の前に tar バックアップを取る。

5.6 AI（Claude Code）指示のガード
存在しない名前を輸入しない（import/クラス/関数名は grep で実体確認）

勝手なファイル移動禁止（ディレクトリ変更・rename は事前同意）

バックグラウンド起動禁止を明記

テストは一歩ずつ（1タスク=1検証、HTTPコードを逐次確認）

6) 停止条件（Stop Rules）
import エラー（ModuleNotFoundError 等）発生 → 即停止 → 実体確認 → devスタブ可否 → 不可なら即ロールバック

バックアップ作成が3分超 → 中止して tar＋除外へ切替

重要フォーム崩れ（ログイン等） → 監視実装を中断しUI契約を先に回復

7) 出発条件（Go/No-Go）
dd3ae5c を STEP3_STABLE_20250816 タグで保護済み

tar＋除外の安全バックアップ手順を確立

前面起動の徹底

AI指示のガードレール文面を準備

8) 再挑戦の最小実装順（ドラフト）
PR-0：DOM契約／app.py改変なし

PR-1：R5（GET条件分岐）—サーバが復元前にクリアしない

PR-2：ui_state 基盤

PR-3：StateManager.cache 書き込み

PR-4：保存→復元サイクル

PR-5：POST-Redirect-GET

PR-6：統合テスト

監視レイヤーは PR-0 の末尾に最小注入 → まず C だけ通す。P5/P6 は後段で段階導入。

9) 結論
最大の失敗は 「一度にやり過ぎ」×「安全装置なし」。

すでに Step3安定版へ復元・安全バックアップ定式化・タグ杭打ちまで完了。

次の Step4 再挑戦は、本メモを SOP（標準作業書） として“一歩ずつ”進める。

