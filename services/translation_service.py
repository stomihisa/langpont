"""
ÁøªË®≥„Çµ„Éº„Éì„Çπ„É¢„Ç∏„É•„Éº„É´
Task #9 AP-1 Phase 1: ChatGPTÁøªË®≥Ê©üËÉΩ„ÅÆÂàÜÈõ¢

„Åì„ÅÆ„É¢„Ç∏„É•„Éº„É´„ÅØ‰ª•‰∏ã„ÅÆÊ©üËÉΩ„ÇíÊèê‰æõ„Åó„Åæ„ÅôÔºö
- ChatGPTÁøªË®≥„ÅÆÂÆüË°å
- OpenAI API„ÅÆÂÆâÂÖ®„Å™„É™„ÇØ„Ç®„Çπ„ÉàÂá¶ÁêÜ
- Áµ±‰∏Ä„Åï„Çå„Åü„Ç®„É©„Éº„Éè„É≥„Éâ„É™„É≥„Ç∞
- ‰æùÂ≠òÊ≥®ÂÖ•„Å´„Çà„ÇãÁñéÁµêÂêàË®≠Ë®à
"""

import time
import os
import requests
from typing import Optional, Callable, Dict, Any
from security.input_validation import EnhancedInputValidator
from security.security_logger import log_security_event, log_access_event


class TranslationService:
    """ÁøªË®≥„Çµ„Éº„Éì„Çπ„ÅÆÁµ±Âêà„ÇØ„É©„Çπ
    
    üöß Task #9-4 AP-1 Phase 4 Êã°Âºµ‰∫àÂÆö:
    - better_translation() „É°„ÇΩ„ÉÉ„ÉâËøΩÂä† (app.py f_better_translationÁßªÂãï)
    - reverse_translation() „É°„ÇΩ„ÉÉ„ÉâËøΩÂä† (app.py f_reverse_translationÁßªÂãï)
    """
    
    def __init__(self, openai_client, logger, labels, 
                 usage_checker: Callable, translation_state_manager):
        """
        ‰æùÂ≠òÊ≥®ÂÖ•„Å´„Çà„Çã„Ç≥„É≥„Çπ„Éà„É©„ÇØ„Çø
        
        Args:
            openai_client: OpenAI client instance
            logger: Application logger
            labels: Multilingual labels
            usage_checker: Usage checking function
            translation_state_manager: State manager for Redis
        """
        self.client = openai_client
        self.logger = logger
        self.labels = labels
        self.usage_checker = usage_checker
        self.state_manager = translation_state_manager
    
    def translate_with_chatgpt(self, text: str, source_lang: str, target_lang: str, 
                              partner_message: str = "", context_info: str = "", 
                              current_lang: str = "jp") -> str:
        """
        ChatGPTÁøªË®≥„ÅÆÂÆüË°å
        
        Args:
            text: ÁøªË®≥ÂØæË±°„ÉÜ„Ç≠„Çπ„Éà
            source_lang: „ÇΩ„Éº„ÇπË®ÄË™û
            target_lang: „Çø„Éº„Ç≤„ÉÉ„ÉàË®ÄË™û
            partner_message: ‰ºöË©±Â±•Ê≠¥
            context_info: ËÉåÊôØÊÉÖÂ†±
            current_lang: UIË®ÄË™û
            
        Returns:
            str: ÁøªË®≥ÁµêÊûú
            
        Raises:
            ValueError: ÂÖ•ÂäõÊ§úË®º„Ç®„É©„Éº
        """
        # ÂåÖÊã¨ÁöÑ„Å™ÂÖ•ÂäõÂÄ§Ê§úË®ºÔºà10000ÊñáÂ≠ó„Åæ„ÅßË®±ÂèØÔºâ
        validations = [
            (text, 10000, "ÁøªË®≥„ÉÜ„Ç≠„Çπ„Éà"),
            (partner_message, 2000, "‰ºöË©±Â±•Ê≠¥"),
            (context_info, 2000, "ËÉåÊôØÊÉÖÂ†±")
        ]

        for input_text, max_len, field_name in validations:
            if input_text:  # Á©∫„Åß„Å™„ÅÑÂ†¥Âêà„ÅÆ„ÅøÊ§úË®º
                is_valid, error_msg = EnhancedInputValidator.validate_text_input(
                    input_text, max_length=max_len, field_name=field_name, current_lang=current_lang
                )
                if not is_valid:
                    self.logger.error(f"Translation validation error: {error_msg}")
                    raise ValueError(error_msg)

        # Ë®ÄË™û„Éö„Ç¢Ê§úË®ºÔºàÂ§öË®ÄË™ûÂØæÂøúÔºâ
        is_valid_pair, pair_error = EnhancedInputValidator.validate_language_pair(
            f"{source_lang}-{target_lang}", current_lang
        )
        if not is_valid_pair:
            self.logger.error(f"Language pair validation error: {pair_error}")
            raise ValueError(pair_error)

        lang_map = {
            "ja": "Japanese", "fr": "French", "en": "English", 
            "es": "Spanish", "de": "German", "it": "Italian"
        }
        target_label = lang_map.get(target_lang, target_lang.capitalize())

        if partner_message.strip() or context_info.strip():
            context_sections = []

            if partner_message.strip():
                context_sections.append(f"PREVIOUS CONVERSATION:\n{partner_message.strip()}")

            if context_info.strip():
                context_sections.append(f"BACKGROUND & RELATIONSHIP:\n{context_info.strip()}")

            context_text = "\n\n".join(context_sections)

            prompt = f"""You are a professional translator specializing in culturally appropriate {target_label} translation.

IMPORTANT CONTEXT TO CONSIDER:
{context_text}

TRANSLATION INSTRUCTIONS:
- Consider the relationship and background information carefully
- Use appropriate formality level based on the context
- Ensure cultural sensitivity and business appropriateness
- Translate naturally while respecting the contextual nuances

TRANSLATE TO {target_label.upper()}:
{text}

Remember: The context above is crucial for determining the appropriate tone, formality, and cultural considerations."""

        else:
            prompt = f"Professional, culturally appropriate translation to {target_label}:\n\n{text}"

        return self.safe_openai_request(prompt, current_lang=current_lang)
    
    def safe_openai_request(self, prompt: str, max_tokens: int = 400, 
                           temperature: float = 0.1, current_lang: str = "jp") -> str:
        """
        OpenAI API„ÅÆÂÆâÂÖ®„Å™„É™„ÇØ„Ç®„Çπ„ÉàÂÆüË°åÔºàÁøªË®≥Áî®„Å´ÊúÄÈÅ©Âåñ„ÉªÂ§öË®ÄË™ûÂØæÂøúÔºâ
        
        Args:
            prompt: APIÈÄÅ‰ø°„Éó„É≠„É≥„Éó„Éà
            max_tokens: ÊúÄÂ§ß„Éà„Éº„ÇØ„É≥Êï∞
            temperature: Ê∏©Â∫¶„Éë„É©„É°„Éº„Çø
            current_lang: UIË®ÄË™û
            
        Returns:
            str: APIÂøúÁ≠îÁµêÊûú
            
        Raises:
            ValueError: API „Ç®„É©„Éº„Åæ„Åü„ÅØÊ§úË®º„Ç®„É©„Éº
        """
        try:
            # „Éó„É≠„É≥„Éó„ÉàÈï∑„ÅÆË®àÁÆó
            prompt_length = len(prompt)

            # ÂãïÁöÑ„Çø„Ç§„É†„Ç¢„Ç¶„ÉàË®≠ÂÆöÔºàÊñáÁ´†Èï∑„Å´Âøú„Åò„Å¶60-120ÁßíÔºâ
            if prompt_length >= 3000:
                timeout = 120
            elif prompt_length >= 1500:
                timeout = 90
            else:
                timeout = 60

            # „Çà„ÇäÈÅ©Âàá„Å™max_tokensË®≠ÂÆö
            if prompt_length > 4000:
                max_tokens = 1500  # Â§ßÂπÖÂ¢óÂä†
                timeout = 180  # 3ÂàÜ„Å´Âª∂Èï∑
            elif prompt_length > 2000:
                max_tokens = 1000
                timeout = 120
            elif prompt_length > 1000:
                max_tokens = 600
            else:
                max_tokens = 400

            # 8000ÊñáÂ≠ó„ÇíË∂Ö„Åà„ÇãÂ†¥Âêà„ÅÆËá™Âãï„Éó„É≠„É≥„Éó„ÉàÁü≠Á∏Æ
            if prompt_length > 8000:
                # Ââç4000ÊñáÂ≠ó + "...[ÁúÅÁï•]..." + Âæå4000ÊñáÂ≠ó
                shortened_prompt = prompt[:4000] + "\n\n...[Content shortened for processing]...\n\n" + prompt[-4000:]
                prompt = shortened_prompt
                log_security_event('PROMPT_SHORTENED', 
                                 f'Prompt shortened from {prompt_length} to {len(prompt)} chars', 'INFO')

            if not prompt or len(prompt.strip()) < 5:
                raise ValueError(self.labels[current_lang]['validation_error_short'])

            # APIÂëº„Å≥Âá∫„ÅóÈñãÂßã
            api_start_time = time.time()
            response = self.client.chat.completions.create(
                model="gpt-3.5-turbo",
                messages=[{"role": "user", "content": prompt}],
                temperature=temperature,
                max_tokens=max_tokens,
                timeout=timeout
            )
            api_duration = int((time.time() - api_start_time) * 1000)

            # APIÂëº„Å≥Âá∫„Åó„É≠„Ç∞Ë®òÈå≤
            try:
                from admin_logger import log_api_call
                log_api_call("openai", True, api_duration, "gpt-3.5-turbo translation")
            except ImportError:
                # „Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØ: Âü∫Êú¨„É≠„Ç∞Âá∫Âäõ
                self.logger.info(f"OpenAI API call completed: {api_duration}ms")

            result = response.choices[0].message.content.strip()

            # ÈÅ©Âàá„Å™Áü≠„ÅÑÁøªË®≥Ë≠¶Âëä„É≠„Ç∏„ÉÉ„ÇØÔºàÁøªË®≥Â∞ÇÁî®Ôºâ
            # „Éó„É≠„É≥„Éó„Éà„Åã„ÇâÂÆüÈöõ„ÅÆÁøªË®≥ÂØæË±°„ÉÜ„Ç≠„Çπ„Éà„ÇíÊé®ÂÆö
            lines = prompt.split('\n')
            actual_text = ""
            for line in lines:
                # „ÄåÁøªË®≥ÂØæË±°„Äç„ÄåTRANSLATE„Äç„ÄåÁøªË®≥„Åó„Å¶„Åè„Å†„Åï„ÅÑ„Äç„Å™„Å©„ÅÆÂæå„ÅÆË°å„ÇíÁøªË®≥ÂØæË±°„Å®Âà§ÂÆö
                if any(keyword in line for keyword in ['ÁøªË®≥ÂØæË±°', 'TRANSLATE', 'ÁøªË®≥„Åó„Å¶„Åè„Å†„Åï„ÅÑ', 'translation to', 'Translate to']):
                    # „Åì„ÅÆË°å‰ª•Èôç„ÇíÁøªË®≥ÂØæË±°„ÉÜ„Ç≠„Çπ„Éà„Å®„Åó„Å¶ÊäΩÂá∫
                    remaining_lines = lines[lines.index(line)+1:]
                    actual_text = '\n'.join(remaining_lines).strip()
                    break

            # ÁøªË®≥ÂØæË±°„ÉÜ„Ç≠„Çπ„Éà„ÅåË¶ã„Å§„Åã„Çâ„Å™„ÅÑÂ†¥Âêà„ÅØ„ÄÅÊúÄÂæå„ÅÆÈï∑„ÅÑË°å„ÇíÁøªË®≥ÂØæË±°„Å®Êé®ÂÆö
            if not actual_text:
                for line in reversed(lines):
                    if len(line.strip()) > 10:  # 10ÊñáÂ≠ó‰ª•‰∏ä„ÅÆË°å
                        actual_text = line.strip()
                        break

            # ÊîπÂñÑ„Åï„Çå„ÅüË≠¶ÂëäÊù°‰ª∂
            if actual_text and len(actual_text) >= 100 and len(result) < 10:
                log_security_event(
                    'SHORT_TRANSLATION_WARNING',
                    f'Translation may be incomplete: source={len(actual_text)} chars, result={len(result)} chars',
                    'WARNING'
                )
                # Áü≠„ÅÑÁøªË®≥„ÅÆÂ†¥Âêà„ÅØÈÅ©Âàá„Å™Ë≠¶Âëä„É°„ÉÉ„Çª„Éº„Ç∏ÔºàÂ§öË®ÄË™ûÂØæÂøúÔºâ
                warning_messages = {
                    "jp": "\n\n‚ö†Ô∏è ÁøªË®≥„Åå‰∏çÂÆåÂÖ®„Å™ÂèØËÉΩÊÄß„Åå„ÅÇ„Çä„Åæ„Åô„ÄÇ",
                    "en": "\n\n‚ö†Ô∏è Translation may be incomplete.",
                    "fr": "\n\n‚ö†Ô∏è La traduction peut √™tre incompl√®te.",
                    "es": "\n\n‚ö†Ô∏è La traducci√≥n puede estar incompleta."
                }
                result += warning_messages.get(current_lang, warning_messages["jp"])
            # 30ÊñáÂ≠óÊú™Ê∫Ä„ÅÆÁü≠„ÅÑÊñá„ÅØË≠¶Âëä„Çπ„Ç≠„ÉÉ„Éó
            elif actual_text and len(actual_text) < 30:
                log_access_event(f'Short text translation completed: source={len(actual_text)}, result={len(result)}')

            if not result or len(result.strip()) < 2:
                raise ValueError(self.labels[current_lang]['validation_error_short'])

            return result

        except requests.exceptions.Timeout:
            log_security_event('OPENAI_TIMEOUT', 
                             f'OpenAI API timeout after {timeout}s for prompt length {prompt_length}', 'WARNING')
            self.logger.error(f"OpenAI API timeout: {timeout}s")
            raise ValueError(f"{self.labels[current_lang]['api_error_timeout']}Ôºà{timeout}ÁßíÔºâ")
        except Exception as e:
            log_security_event('OPENAI_ERROR', f'OpenAI API error: {str(e)}', 'ERROR')
            self.logger.error(f"OpenAI API error: {str(e)}")
            raise ValueError(self.labels[current_lang]['api_error_general'])
    
    def translate_with_gemini(self, text: str, source_lang: str, target_lang: str, 
                             partner_message: str = "", context_info: str = "", 
                             current_lang: str = "jp") -> str:
        """
        GeminiÁøªË®≥„ÅÆÂÆüË°å
        
        Args:
            text: ÁøªË®≥ÂØæË±°„ÉÜ„Ç≠„Çπ„Éà
            source_lang: „ÇΩ„Éº„ÇπË®ÄË™û
            target_lang: „Çø„Éº„Ç≤„ÉÉ„ÉàË®ÄË™û
            partner_message: ‰ºöË©±Â±•Ê≠¥
            context_info: ËÉåÊôØÊÉÖÂ†±
            current_lang: UIË®ÄË™û
            
        Returns:
            str: ÁøªË®≥ÁµêÊûú
            
        Raises:
            ValueError: ÂÖ•ÂäõÊ§úË®º„Ç®„É©„Éº„Åæ„Åü„ÅØAPI „Ç®„É©„Éº
        """
        # Gemini API„Ç≠„ÉºÁ¢∫Ë™ç
        GEMINI_API_KEY = os.getenv("GEMINI_API_KEY")
        if not GEMINI_API_KEY:
            error_messages = {
                "jp": "‚ö†Ô∏è Gemini API„Ç≠„Éº„Åå„ÅÇ„Çä„Åæ„Åõ„Çì",
                "en": "‚ö†Ô∏è Gemini API key not found",
                "fr": "‚ö†Ô∏è Cl√© API Gemini introuvable",
                "es": "‚ö†Ô∏è Clave API de Gemini no encontrada"
            }
            raise ValueError(error_messages.get(current_lang, error_messages["jp"]))

        # ÂåÖÊã¨ÁöÑ„Å™ÂÖ•ÂäõÂÄ§Ê§úË®ºÔºà10000ÊñáÂ≠ó„Åæ„ÅßË®±ÂèØÔºâ
        validations = [
            (text, 10000, "ÁøªË®≥„ÉÜ„Ç≠„Çπ„Éà"),
            (partner_message, 2000, "‰ºöË©±Â±•Ê≠¥"),
            (context_info, 2000, "ËÉåÊôØÊÉÖÂ†±")
        ]

        for input_text, max_len, field_name in validations:
            if input_text:  # Á©∫„Åß„Å™„ÅÑÂ†¥Âêà„ÅÆ„ÅøÊ§úË®º
                is_valid, error_msg = EnhancedInputValidator.validate_text_input(
                    input_text, max_length=max_len, field_name=field_name, current_lang=current_lang
                )
                if not is_valid:
                    self.logger.error(f"Gemini validation error: {error_msg}")
                    raise ValueError(error_msg)

        # Ë®ÄË™û„Éö„Ç¢Ê§úË®º
        is_valid_pair, pair_error = EnhancedInputValidator.validate_language_pair(
            f"{source_lang}-{target_lang}", current_lang
        )
        if not is_valid_pair:
            self.logger.error(f"Language pair validation error: {pair_error}")
            raise ValueError(pair_error)

        # Ë®ÄË™û„Éû„ÉÉ„Éó
        lang_map = {
            "ja": "Japanese", "fr": "French", "en": "English",
            "es": "Spanish", "de": "German", "it": "Italian"
        }

        source_label = lang_map.get(source_lang, source_lang.capitalize())
        target_label = lang_map.get(target_lang, target_lang.capitalize())

        # GeminiÁî®„Éó„É≠„É≥„Éó„ÉàÊßãÁØâ
        prompt = f"""
You are a professional {source_label} to {target_label} translator.
Using the context below, provide ONLY the {target_label} translation (no explanations or notes).

LANGUAGE PAIR: {source_label} ‚Üí {target_label}

--- Previous conversation ---
{partner_message or "(None)"}

--- Background context ---
{context_info or "(None)"}

--- TEXT TO TRANSLATE TO {target_label.upper()} ---
{text}

IMPORTANT: Respond ONLY with the {target_label} translation.
        """.strip()

        return self.safe_gemini_request(prompt, current_lang=current_lang)
    
    def safe_gemini_request(self, prompt: str, current_lang: str = "jp") -> str:
        """
        Gemini API„ÅÆÂÆâÂÖ®„Å™„É™„ÇØ„Ç®„Çπ„ÉàÂÆüË°å
        
        Args:
            prompt: APIÈÄÅ‰ø°„Éó„É≠„É≥„Éó„Éà
            current_lang: UIË®ÄË™û
            
        Returns:
            str: APIÂøúÁ≠îÁµêÊûú
            
        Raises:
            ValueError: API „Ç®„É©„Éº„Åæ„Åü„ÅØÊ§úË®º„Ç®„É©„Éº
        """
        try:
            GEMINI_API_KEY = os.getenv("GEMINI_API_KEY")
            if not GEMINI_API_KEY:
                raise ValueError("Gemini API key not available")

            # „Éó„É≠„É≥„Éó„ÉàÊ§úË®º
            if not prompt or len(prompt.strip()) < 5:
                raise ValueError(self.labels[current_lang]['validation_error_short'])

            # API „É™„ÇØ„Ç®„Çπ„ÉàË®≠ÂÆö
            url = f"https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-pro-latest:generateContent?key={GEMINI_API_KEY}"
            headers = {"Content-Type": "application/json"}
            data = {"contents": [{"parts": [{"text": prompt}]}]}

            # APIÂëº„Å≥Âá∫„ÅóÈñãÂßã
            api_start_time = time.time()
            response = requests.post(url, headers=headers, json=data, timeout=30)
            api_duration = int((time.time() - api_start_time) * 1000)

            # APIÂëº„Å≥Âá∫„Åó„É≠„Ç∞Ë®òÈå≤
            try:
                from admin_logger import log_api_call
                log_api_call("gemini", response.status_code == 200, api_duration, "gemini-1.5-pro translation")
            except ImportError:
                # „Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØ: Âü∫Êú¨„É≠„Ç∞Âá∫Âäõ
                self.logger.info(f"Gemini API call completed: {api_duration}ms, status: {response.status_code}")

            if response.status_code == 200:
                result = response.json()["candidates"][0]["content"]["parts"][0]["text"]
                
                # ÁµêÊûúÊ§úË®º
                if not result or len(result.strip()) < 2:
                    raise ValueError(self.labels[current_lang]['validation_error_short'])
                
                return result.strip()
            else:
                log_security_event(
                    'GEMINI_API_ERROR',
                    f'Gemini API error: {response.status_code}',
                    'ERROR'
                )
                error_messages = {
                    "jp": f"Gemini API „Ç®„É©„Éº: {response.status_code}",
                    "en": f"Gemini API error: {response.status_code}",
                    "fr": f"Erreur API Gemini: {response.status_code}",
                    "es": f"Error API Gemini: {response.status_code}"
                }
                raise ValueError(error_messages.get(current_lang, error_messages["jp"]))

        except requests.exceptions.Timeout:
            log_security_event('GEMINI_TIMEOUT', 'Gemini API timeout after 30s', 'WARNING')
            self.logger.error("Gemini API timeout: 30s")
            timeout_messages = {
                "jp": "‚ö†Ô∏è Gemini API„Åå„Çø„Ç§„É†„Ç¢„Ç¶„Éà„Åó„Åæ„Åó„ÅüÔºà30ÁßíÔºâ",
                "en": "‚ö†Ô∏è Gemini API timeout (30 seconds)",
                "fr": "‚ö†Ô∏è Timeout de l'API Gemini (30 secondes)",
                "es": "‚ö†Ô∏è Tiempo de espera de API Gemini (30 segundos)"
            }
            raise ValueError(timeout_messages.get(current_lang, timeout_messages["jp"]))
        except Exception as e:
            log_security_event('GEMINI_REQUEST_ERROR', f'Gemini request error: {str(e)}', 'ERROR')
            self.logger.error(f"Gemini API error: {str(e)}")
            error_messages = {
                "jp": f"Gemini API „Ç®„É©„Éº: {str(e)}",
                "en": f"Gemini API error: {str(e)}",
                "fr": f"Erreur API Gemini: {str(e)}",
                "es": f"Error API Gemini: {str(e)}"
            }
            raise ValueError(error_messages.get(current_lang, error_messages["jp"]))
    
    def better_translation(self, text_to_improve: str, source_lang: str = "fr", 
                          target_lang: str = "en", current_lang: str = "jp") -> str:
        """
        ÁøªË®≥ÁµêÊûú„Çí„Çà„ÇäËá™ÁÑ∂„Å™Ë°®Áèæ„Å´ÊîπÂñÑ„Åô„Çã
        
        Args:
            text_to_improve (str): ÊîπÂñÑÂØæË±°„ÅÆ„ÉÜ„Ç≠„Çπ„ÉàÔºàÂøÖÈ†àÔºâ
            source_lang (str): ÁøªË®≥ÂÖÉË®ÄË™ûÔºà„Éá„Éï„Ç©„É´„Éà: "fr"Ôºâ
            target_lang (str): ÁøªË®≥ÂÖàË®ÄË™ûÔºà„Éá„Éï„Ç©„É´„Éà: "en"Ôºâ
            current_lang (str): UIË°®Á§∫Ë®ÄË™ûÔºà„Éá„Éï„Ç©„É´„Éà: "jp"Ôºâ
        
        Returns:
            str: ÊîπÂñÑ„Åï„Çå„ÅüÁøªË®≥„ÉÜ„Ç≠„Çπ„Éà
            
        Raises:
            ValueError: ÂÖ•ÂäõÂÄ§Ê§úË®º„Ç®„É©„Éº
            Exception: OpenAI API„Ç®„É©„Éº
        """
        # ÂÖ•ÂäõÂÄ§Ê§úË®ºÔºàÂ§öË®ÄË™ûÂØæÂøúÔºâ
        is_valid, error_msg = EnhancedInputValidator.validate_text_input(
            text_to_improve, field_name="ÊîπÂñÑÂØæË±°„ÉÜ„Ç≠„Çπ„Éà", current_lang=current_lang
        )
        if not is_valid:
            raise ValueError(error_msg)

        is_valid_pair, pair_error = EnhancedInputValidator.validate_language_pair(
            f"{source_lang}-{target_lang}", current_lang
        )
        if not is_valid_pair:
            raise ValueError(pair_error)

        # Ë®ÄË™û„Éû„ÉÉ„Éî„É≥„Ç∞
        lang_map = {
            "ja": "Êó•Êú¨Ë™û", 
            "fr": "„Éï„É©„É≥„ÇπË™û", 
            "en": "Ëã±Ë™û", 
            "es": "„Çπ„Éö„Ç§„É≥Ë™û", 
            "de": "„Éâ„Ç§„ÉÑË™û", 
            "it": "„Ç§„Çø„É™„Ç¢Ë™û"
        }
        target_label = lang_map.get(target_lang, target_lang)

        # „Éó„É≠„É≥„Éó„ÉàÁîüÊàê
        prompt = f"„Åì„ÅÆ{target_label}„Çí„ÇÇ„Å£„Å®Ëá™ÁÑ∂„Å™{target_label}„ÅÆÊñáÁ´†„Å´ÊîπÂñÑ„Åó„Å¶„Åè„Å†„Åï„ÅÑÔºö{text_to_improve}"

        # OpenAI APIÂëº„Å≥Âá∫„Åó
        return self.safe_openai_request(prompt, current_lang=current_lang)
    
    def reverse_translation(self, translated_text: str, target_lang: str, 
                           source_lang: str, current_lang: str = "jp") -> str:
        """
        ÁøªË®≥ÁµêÊûú„ÅÆÈÄÜÁøªË®≥ÂÆüË°å
        Task #9-4 AP-1 Phase 4 Step2: app.py f_reverse_translation „ÅÆServiceÂ±§ÂÆüË£Ö
        
        Args:
            translated_text: ÈÄÜÁøªË®≥ÂØæË±°„ÉÜ„Ç≠„Çπ„Éà
            target_lang: ÂÖÉ„ÅÆÁøªË®≥ÂÖàË®ÄË™ûÔºàÈÄÜÁøªË®≥„Åß„ÅØÂÖÉË®ÄË™û„Å´„Å™„ÇãÔºâ
            source_lang: ÂÖÉ„ÅÆÁøªË®≥ÂÖÉË®ÄË™ûÔºàÈÄÜÁøªË®≥„Åß„ÅØÂÖàË®ÄË™û„Å´„Å™„ÇãÔºâ
            current_lang: UIË®ÄË™û
            
        Returns:
            str: ÈÄÜÁøªË®≥ÁµêÊûú
            
        Raises:
            ValueError: ÂÖ•ÂäõÂÄ§Ê§úË®º„Ç®„É©„Éº
        """
        if not translated_text:
            return "(ÁøªË®≥„ÉÜ„Ç≠„Çπ„Éà„ÅåÁ©∫„Åß„Åô)"

        # ÂÖ•ÂäõÂÄ§Ê§úË®ºÔºàÂ§öË®ÄË™ûÂØæÂøúÔºâ
        is_valid, error_msg = EnhancedInputValidator.validate_text_input(
            translated_text, field_name="ÈÄÜÁøªË®≥„ÉÜ„Ç≠„Çπ„Éà", current_lang=current_lang
        )
        if not is_valid:
            self.logger.error(f"Reverse translation validation error: {error_msg}")
            raise ValueError(error_msg)

        is_valid_pair, pair_error = EnhancedInputValidator.validate_language_pair(
            f"{source_lang}-{target_lang}", current_lang
        )
        if not is_valid_pair:
            self.logger.error(f"Reverse translation language pair validation error: {pair_error}")
            raise ValueError(pair_error)

        lang_map = {"ja": "Japanese", "fr": "French", "en": "English", "es": "Spanish", "de": "German", "it": "Italian"}
        source_label = lang_map.get(source_lang, source_lang.capitalize())

        prompt = f"""Professional translation task: Translate the following text to {source_label}.

TEXT TO TRANSLATE TO {source_label.upper()}:
{translated_text}

IMPORTANT: Respond ONLY with the {source_label} translation."""

        try:
            return self.safe_openai_request(prompt, max_tokens=300, current_lang=current_lang)
        except Exception as e:
            self.logger.error(f"Reverse translation API error: {str(e)}")
            return f"ÈÄÜÁøªË®≥„Ç®„É©„Éº: {str(e)}"